(gdb) disassemble phase_1
Dump of assembler code for function phase_1:
   0x0000000000401440 <+0>:     sub    $0x8,%rsp                      // common stack alignment operation at the beginning of a function, but it only appears when alignment or local variables are needed
   0x0000000000401444 <+4>:     mov    $0x402460,%esi                 // store the address of string that compares with user input
   0x0000000000401449 <+9>:     call   0x401873 <strings_not_equal>   // call the function to compare two strings
   0x000000000040144e <+14>:    test   %eax,%eax                      // check the return value of strings_not_equal
   0x0000000000401450 <+16>:    jne    0x401457 <phase_1+23>          // if not equal, jump to explode_bomb
   0x0000000000401452 <+18>:    add    $0x8,%rsp
   0x0000000000401456 <+22>:    ret
   0x0000000000401457 <+23>:    call   0x401c7a <explode_bomb>
   0x000000000040145c <+28>:    jmp    0x401452 <phase_1+18>
End of assembler dump.

(gdb) x /s 0x402460
0x402460:       "Two plus two is ... ten. In base four! I'm fine!"

=========================================================================

(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x000000000040145e <+0>:     push   %rbp                          // recored the base pointer
   0x000000000040145f <+1>:     push   %rbx                          // save the value of rbx register, because it will be motiffied in this function        
   0x0000000000401460 <+2>:     sub    $0x28,%rsp                    // allocate 40 bytes on the stack for local variables
   0x0000000000401464 <+6>:     mov    %rsp,%rbx                     // store the address of the first local variable array into rbx (e.g., int *array)
   0x0000000000401467 <+9>:     mov    %rsp,%rsi                     // prepare the first argument for read_six_numbers (e.g., array[0])
   0x000000000040146a <+12>:    call   0x401c9c <read_six_numbers>   // read six numbers from user input and store them in the local variable array
   0x000000000040146f <+17>:    lea    0x14(%rsp),%rbp               // set rbp to point to the end of the local variable array (the last element)
   0x0000000000401474 <+22>:    jmp    0x401489 <phase_2+43>
   0x0000000000401476 <+24>:    cs nopw 0x0(%rax,%rax,1)
   0x0000000000401480 <+34>:    add    $0x4,%rbx。                   // move to the next element in the array
   0x0000000000401484 <+38>:    cmp    %rbp,%rbx                     // check if we have reached the end of the array
   0x0000000000401487 <+41>:    je     0x40149a <phase_2+60>
   0x0000000000401489 <+43>:    mov    (%rbx),%eax                   // start compare, from the first numbers in the array
   0x000000000040148b <+45>:    add    $0x5,%eax                     // array[i] + 5
   0x000000000040148e <+48>:    cmp    %eax,0x4(%rbx).               // compare array[i] + 5 with array[i+1]
   0x0000000000401491 <+51>:    je     0x401480 <phase_2+34>         // [ *** need to be equal, otherwise explode_bomb *** ] if equal, continue to the next number
   0x0000000000401493 <+53>:    call   0x401c7a <explode_bomb>
   0x0000000000401498 <+58>:    jmp    0x401480 <phase_2+34>
   0x000000000040149a <+60>:    add    $0x28,%rsp
   0x000000000040149e <+64>:    pop    %rbx
   0x000000000040149f <+65>:    pop    %rbp
   0x00000000004014a0 <+66>:    ret
End of assembler dump.

=========================================================================

(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x00000000004014a1 <+0>:     sub    $0x18,%rsp。                    // for scanf local variables
   // prepare arguments for sscanf(input, "%d %c %d", &num1, &ch ...), so rdi is input string, rsi is format string
   0x00000000004014a5 <+4>:     lea    0x7(%rsp),%rcx                  // 2nd local variable, might be char
   0x00000000004014aa <+9>:     lea    0xc(%rsp),%rdx                  // 1st local variable
   0x00000000004014af <+14>:    lea    0x8(%rsp),%r8                   // 3rd local variable
   0x00000000004014b4 <+19>:    mov    $0x402074,%esi.                 // format string "%d %c %d"
   0x00000000004014b9 <+24>:    mov    $0x0,%eax                       // use 0 SSE parameter(i.e., no floating point arguments)
   0x00000000004014be <+29>:    call   0x401150 <__isoc99_sscanf@plt>
   0x00000000004014c3 <+34>:    cmp    $0x2,%eax                       // check if sscanf successfully parsed 3 items
   0x00000000004014c6 <+37>:    jle    0x4014de <phase_3+61>           // if not, explode_bomb
   0x00000000004014c8 <+39>:    cmpl   $0x7,0xc(%rsp)                  // chech if the 1st number is in the range 0 to 7
   0x00000000004014cd <+44>:    ja     0x4015cf <phase_3+302>          // if above 7, explode_bomb
   0x00000000004014d3 <+50>:    mov    0xc(%rsp),%eax.                 // move the 1st number into eax
   0x00000000004014d7 <+54>:    jmp    *0x4025c0(,%rax,8)              // jump table base is at 0x4025c0, each store 8 bytes (address) to point to different cases
   0x00000000004014de <+61>:    call   0x401c7a <explode_bomb>
   0x00000000004014e3 <+66>:    jmp    0x4014c8 <phase_3+39>
   // case 0, find by print /x *0x4025c0
   0x00000000004014e5 <+68>:    mov    $0x6d,%eax                     // case 0: set eax = 0x6d (109) = ascii 'm'
   0x00000000004014ea <+73>:    cmpl   $0x2fb,0x8(%rsp)               // compare the 3rd number with 0x2fb (763)
   0x00000000004014f2 <+81>:    je     0x4015d9 <phase_3+312>         // if equal, jump to the end to check the char 
   0x00000000004014f8 <+87>:    call   0x401c7a <explode_bomb>
   0x00000000004014fd <+92>:    mov    $0x6d,%eax                     // redundant, just avoid explode return
   0x0000000000401502 <+97>:    jmp    0x4015d9 <phase_3+312>
   0x0000000000401507 <+102>:   mov    $0x64,%eax                     // case 1: set eax = 0x64 (100) = ascii 'd'
   0x000000000040150c <+107>:   cmpl   $0x1e8,0x8(%rsp)               // compare the 3rd number with 0x1e8 (488)
   0x0000000000401514 <+115>:   je     0x4015d9 <phase_3+312>         // if equal, jump to the end to check the char
   0x000000000040151a <+121>:   call   0x401c7a <explode_bomb>
   0x000000000040151f <+126>:   mov    $0x64,%eax
   0x0000000000401524 <+131>:   jmp    0x4015d9 <phase_3+312>
   0x0000000000401529 <+136>:   mov    $0x68,%eax                     // case 2: set eax = 0x68 (104) = ascii 'h'
   0x000000000040152e <+141>:   cmpl   $0x277,0x8(%rsp)               // compare the 3rd number with 0x277 (631)
   0x0000000000401536 <+149>:   je     0x4015d9 <phase_3+312>         // if equal, jump to the end to check the char
   0x000000000040153c <+155>:   call   0x401c7a <explode_bomb>
   0x0000000000401541 <+160>:   mov    $0x68,%eax
   0x0000000000401546 <+165>:   jmp    0x4015d9 <phase_3+312>
   0x000000000040154b <+170>:   mov    $0x74,%eax
   0x0000000000401550 <+175>:   cmpl   $0x1dc,0x8(%rsp)
   0x0000000000401558 <+183>:   je     0x4015d9 <phase_3+312>
   0x000000000040155a <+185>:   call   0x401c7a <explode_bomb>
   0x000000000040155f <+190>:   mov    $0x74,%eax
   0x0000000000401564 <+195>:   jmp    0x4015d9 <phase_3+312>
   0x0000000000401566 <+197>:   mov    $0x65,%eax
   0x000000000040156b <+202>:   cmpl   $0x26a,0x8(%rsp)
   0x0000000000401573 <+210>:   je     0x4015d9 <phase_3+312>
   0x0000000000401575 <+212>:   call   0x401c7a <explode_bomb>
   0x000000000040157a <+217>:   mov    $0x65,%eax
   0x000000000040157f <+222>:   jmp    0x4015d9 <phase_3+312>
   0x0000000000401581 <+224>:   mov    $0x6d,%eax
   0x0000000000401586 <+229>:   cmpl   $0x3e,0x8(%rsp)
   0x000000000040158b <+234>:   je     0x4015d9 <phase_3+312>
   0x000000000040158d <+236>:   call   0x401c7a <explode_bomb>
   0x0000000000401592 <+241>:   mov    $0x6d,%eax
   0x0000000000401597 <+246>:   jmp    0x4015d9 <phase_3+312>
   0x0000000000401599 <+248>:   mov    $0x75,%eax
   0x000000000040159e <+253>:   cmpl   $0x14d,0x8(%rsp)
   0x00000000004015a6 <+261>:   je     0x4015d9 <phase_3+312>
   0x00000000004015a8 <+263>:   call   0x401c7a <explode_bomb>
   0x00000000004015ad <+268>:   mov    $0x75,%eax
   0x00000000004015b2 <+273>:   jmp    0x4015d9 <phase_3+312>
   0x00000000004015b4 <+275>:   mov    $0x79,%eax                   // case 7: set eax = 0x79 (121) = ascii 'y' 
   0x00000000004015b9 <+280>:   cmpl   $0x3dc,0x8(%rsp)             // compare the 3rd number with 0x3dc (988)
   0x00000000004015c1 <+288>:   je     0x4015d9 <phase_3+312>
   0x00000000004015c3 <+290>:   call   0x401c7a <explode_bomb>
   0x00000000004015c8 <+295>:   mov    $0x79,%eax
   0x00000000004015cd <+300>:   jmp    0x4015d9 <phase_3+312>
   0x00000000004015cf <+302>:   call   0x401c7a <explode_bomb>
   0x00000000004015d4 <+307>:   mov    $0x75,%eax
   0x00000000004015d9 <+312>:   cmp    %al,0x7(%rsp).              // compare input char with the expected char sroted in eax
   0x00000000004015dd <+316>:   jne    0x4015e4 <phase_3+323>
   0x00000000004015df <+318>:   add    $0x18,%rsp
   0x00000000004015e3 <+322>:   ret
   0x00000000004015e4 <+323>:   call   0x401c7a <explode_bomb>
   0x00000000004015e9 <+328>:   jmp    0x4015df <phase_3+318>
End of assembler dump.


=========================================================================

(gdb) disas phase_4
Dump of assembler code for function phase_4:
   0x0000000000401606 <+0>:     sub    $0x18,%rsp                       // allocate space for local variables
    // prepare arguments for sscanf(input, "%d %c %d", &num1, &ch ...), so rdi is input string, rsi is format string
   0x000000000040160a <+4>:     lea    0xc(%rsp),%rdx                   // address of 1st variable
   0x000000000040160f <+9>:     mov    $0x40207a,%esi                   // format string "%d"
   0x0000000000401614 <+14>:    mov    $0x0,%eax                        // use 0 SSE parameter(i.e., no floating point arguments)
   0x0000000000401619 <+19>:    call   0x401150 <__isoc99_sscanf@plt>
   0x000000000040161e <+24>:    cmp    $0x1,%eax                        // check if sscanf successfully parsed 1 item
   0x0000000000401621 <+27>:    jne    0x40162a <phase_4+36>            // if not, explode_bomb
   0x0000000000401623 <+29>:    cmpl   $0x0,0xc(%rsp)                   // check if the number is positive
   0x0000000000401628 <+34>:    jg     0x40162f <phase_4+41>
   0x000000000040162a <+36>:    call   0x401c7a <explode_bomb>
   0x000000000040162f <+41>:    mov    0xc(%rsp),%edi                   // move the input number into edi (first argument for func4)
   0x0000000000401633 <+45>:    call   0x4015eb <func4>                 // func4 is factorial function
   0x0000000000401638 <+50>:    cmp    $0x58980,%eax                    // compare the return value of func4 with 0x58980 (362880) = 9!
   0x000000000040163d <+55>:    jne    0x401644 <phase_4+62>
   0x000000000040163f <+57>:    add    $0x18,%rsp
   0x0000000000401643 <+61>:    ret
   0x0000000000401644 <+62>:    call   0x401c7a <explode_bomb>
   0x0000000000401649 <+67>:    jmp    0x40163f <phase_4+57>
End of assembler dump.


(gdb) disas func4
Dump of assembler code for function func4:
   0x00000000004015eb <+0>:     mov    $0x1,%eax               // base case: return 1
   0x00000000004015f0 <+5>:     cmp    $0x1,%edi               // compare input argument with 1
   0x00000000004015f3 <+8>:     jle    0x401605 <func4+26>     // if less than or equal to 1, return 1
   0x00000000004015f5 <+10>:    push   %rbx                    // store rbx register in the stack
   0x00000000004015f6 <+11>:    mov    %edi,%ebx               // move input argument into ebx for multiplication later
   0x00000000004015f8 <+13>:    lea    -0x1(%rdi),%edi         // prepare argument for recursive call: n - 1
   0x00000000004015fb <+16>:    call   0x4015eb <func4>        // recursive call
   0x0000000000401600 <+21>:    imul   %ebx,%eax
   0x0000000000401603 <+24>:    pop    %rbx
   0x0000000000401604 <+25>:    ret
   0x0000000000401605 <+26>:    ret
End of assembler dump.

=========================================================================

(gdb) disas phase_5
Dump of assembler code for function phase_5:
   0x000000000040164b <+0>:     push   %rbx
   0x000000000040164c <+1>:     mov    %rdi,%rbx                     // move the input string pointer into rbx
   0x000000000040164f <+4>:     call   0x401851 <string_length>
   0x0000000000401654 <+9>:     cmp    $0x6,%eax                     // check if the length of input string is 6  
   0x0000000000401657 <+12>:    jne    0x40169d <phase_5+82>
   0x0000000000401659 <+14>:    mov    %rbx,%rax                     // rax = the start of the input string
   0x000000000040165c <+17>:    lea    0x6(%rbx),%rdi                // rdi = the end of the input string
   0x0000000000401660 <+21>:    mov    $0x0,%ecx                     // ecx will store the sum
   0x0000000000401665 <+26>:    data16 cs nopw 0x0(%rax,%rax,1)
   0x0000000000401670 <+37>:    data16 cs nopw 0x0(%rax,%rax,1)
   0x000000000040167b <+48>:    nopl   0x0(%rax,%rax,1)
   0x0000000000401680 <+53>:    movzbl (%rax),%edx                   // load the current character from the input string
   0x0000000000401683 <+56>:    and    $0xf,%edx                     // get the lower 4 bits of the character (i.e., map '0'-'9','a'-'f' to 0-15, so we can assume array index is 0-15)
   0x0000000000401686 <+59>:    add    0x402600(,%rdx,4),%ecx        // add the value from the array to ecx (sum += array[index])
   0x000000000040168d <+66>:    add    $0x1,%rax                     // move to the next character
   0x0000000000401691 <+70>:    cmp    %rdi,%rax                     // check if we have processed all 6 characters
   0x0000000000401694 <+73>:    jne    0x401680 <phase_5+53>
   0x0000000000401696 <+75>:    cmp    $0x33,%ecx                    // compare the sum with 0x33 (51)
   0x0000000000401699 <+78>:    jne    0x4016a4 <phase_5+89>
   0x000000000040169b <+80>:    pop    %rbx
   0x000000000040169c <+81>:    ret
   0x000000000040169d <+82>:    call   0x401c7a <explode_bomb>
   0x00000000004016a2 <+87>:    jmp    0x401659 <phase_5+14>
   0x00000000004016a4 <+89>:    call   0x401c7a <explode_bomb>
   0x00000000004016a9 <+94>:    jmp    0x40169b <phase_5+80>
End of assembler dump.

(gdb) x /16wd 0x402600
0x402600 <array.0>:     2*       10      6       1
0x402610 <array.0+16>:  12      16*      9       3*
0x402620 <array.0+32>:  4       7*       14      5
0x402630 <array.0+48>:  11      8*       15*      13

one possible solution is to choose @%')-n
the ascii lower 4 bit is 0, 5, 7, 9, d, e to get sum 51

@: 0x40
%: 0x25
': 0x27
): 0x29
-: 0x2d
n: 0x6e

=========================================================================

(gdb) disas phase_6
Dump of assembler code for function phase_6:
   0x0000000000401712 <+0>:     push   %rbx
   0x0000000000401713 <+1>:     mov    $0xa,%edx
   0x0000000000401718 <+6>:     mov    $0x0,%esi
   0x000000000040171d <+11>:    call   0x401130 <strtol@plt>
   0x0000000000401722 <+16>:    mov    %rax,%rbx
   0x0000000000401725 <+19>:    mov    $0x404300,%edi
   0x000000000040172a <+24>:    call   0x4016ab <fun6>
   0x000000000040172f <+29>:    mov    0x8(%rax),%rax
   0x0000000000401733 <+33>:    mov    0x8(%rax),%rax
   0x0000000000401737 <+37>:    cmp    %ebx,(%rax)
   0x0000000000401739 <+39>:    jne    0x40173d <phase_6+43>
   0x000000000040173b <+41>:    pop    %rbx
   0x000000000040173c <+42>:    ret
   0x000000000040173d <+43>:    call   0x401c7a <explode_bomb>
   0x0000000000401742 <+48>:    jmp    0x40173b <phase_6+41>
End of assembler dump.